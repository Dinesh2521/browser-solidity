'use strict'

var Module = { // eslint-disable-line
  cwrap: function () { return arguments[0] === 'version' ? version : compile },
  writeStringToMemory: function () {},
  setValue: function () {},
  Pointer_stringify: function () {},
  Runtime: {
    addFunction: function () {},
    removeFunction: function () {}
  },
  _compileJSONMulti: {},
  _compileJSONCallback: {},
  _compileJSON: {}
}

function compile (source, optimization, missingInputs) {
  if (typeof source === 'string') {
    source = JSON.parse(source)
  }
  var key = optimization.toString()
  for (var k in source.sources) {
    key += k + source.sources[k]
  }
  key = key.replace(/(\t)|(\n)|( )/g, '')
  var data = mockData[key] // eslint-disable-line
  if (data === undefined) {
    return JSON.stringify({
      errors: ['mock compiler: source not found']
    })
  } else {
    data.missingInputs.map(function (item, i) {
      if (missingInputs) {
        missingInputs(item)
      }
    })
  }
  return JSON.stringify(data.result)
}

function version () {
  return 'mock compiler'
}


var mockData = {"1Untitledcontracttest1{}contracttest2{}":{"key":"1Untitledcontracttest1{}contracttest2{}","source":{"sources":{"Untitled":"contract test1 {} contract test2 {}"}},"optimization":1,"missingInputs":[],"result":{"contracts":{"test1":{"assembly":{".code":[{"begin":0,"end":17,"name":"PUSH","value":"60"},{"begin":0,"end":17,"name":"PUSH","value":"40"},{"begin":0,"end":17,"name":"MSTORE"},{"begin":0,"end":17,"name":"PUSH #[$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":0,"end":17,"name":"DUP1"},{"begin":0,"end":17,"name":"PUSH [$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":0,"end":17,"name":"PUSH","value":"0"},{"begin":0,"end":17,"name":"CODECOPY"},{"begin":0,"end":17,"name":"PUSH","value":"0"},{"begin":0,"end":17,"name":"RETURN"}],".data":{"0":{".code":[{"begin":0,"end":17,"name":"PUSH","value":"60"},{"begin":0,"end":17,"name":"PUSH","value":"40"},{"begin":0,"end":17,"name":"MSTORE"},{"begin":0,"end":17,"name":"PUSH [ErrorTag]"},{"begin":0,"end":17,"name":"JUMP"}]}}},"bytecode":"606060405260088060106000396000f36060604052600256","functionHashes":{},"gasEstimates":{"creation":[39,1600],"external":{},"internal":{}},"interface":"[]\n","opcodes":"PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x8 DUP1 PUSH1 0x10 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x2 JUMP ","runtimeBytecode":"6060604052600256","srcmap":"0:17:0:-;;;;;;;;;","srcmapRuntime":"0:17:0:-;;;;"},"test2":{"assembly":{".code":[{"begin":18,"end":35,"name":"PUSH","value":"60"},{"begin":18,"end":35,"name":"PUSH","value":"40"},{"begin":18,"end":35,"name":"MSTORE"},{"begin":18,"end":35,"name":"PUSH #[$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":18,"end":35,"name":"DUP1"},{"begin":18,"end":35,"name":"PUSH [$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":18,"end":35,"name":"PUSH","value":"0"},{"begin":18,"end":35,"name":"CODECOPY"},{"begin":18,"end":35,"name":"PUSH","value":"0"},{"begin":18,"end":35,"name":"RETURN"}],".data":{"0":{".code":[{"begin":18,"end":35,"name":"PUSH","value":"60"},{"begin":18,"end":35,"name":"PUSH","value":"40"},{"begin":18,"end":35,"name":"MSTORE"},{"begin":18,"end":35,"name":"PUSH [ErrorTag]"},{"begin":18,"end":35,"name":"JUMP"}]}}},"bytecode":"606060405260088060106000396000f36060604052600256","functionHashes":{},"gasEstimates":{"creation":[39,1600],"external":{},"internal":{}},"interface":"[]\n","opcodes":"PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x8 DUP1 PUSH1 0x10 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x2 JUMP ","runtimeBytecode":"6060604052600256","srcmap":"18:17:0:-;;;;;;;;;","srcmapRuntime":"18:17:0:-;;;;"}},"errors":["Untitled:1:1: Warning: Source file does not specify required compiler version!Consider adding \"pragma solidity ^0.4.3\ncontract test1 {} contract test2 {}\n^---------------------------------^\n"],"formal":{"errors":["Untitled:1:19: Error: More than one contract not supported.\ncontract test1 {} contract test2 {}\n                  ^---------------^\n"]},"sourceList":["Untitled"],"sources":{"Untitled":{"AST":{"children":[{"attributes":{"fullyImplemented":true,"isLibrary":false,"linearizedBaseContracts":[5600292],"name":"test1"},"children":[],"id":5600292,"name":"ContractDefinition","src":"0:17:0"},{"attributes":{"fullyImplemented":true,"isLibrary":false,"linearizedBaseContracts":[5600468],"name":"test2"},"children":[],"id":5600468,"name":"ContractDefinition","src":"18:17:0"}],"name":"SourceUnit"}}}}},"0Untitledcontracttest1{}contracttest2{}":{"key":"0Untitledcontracttest1{}contracttest2{}","source":{"sources":{"Untitled":"contract test1 {} contract test2 {}"}},"optimization":0,"missingInputs":[],"result":{"contracts":{"test1":{"assembly":{".code":[{"begin":0,"end":17,"name":"PUSH","value":"60"},{"begin":0,"end":17,"name":"PUSH","value":"40"},{"begin":0,"end":17,"name":"MSTORE"},{"begin":0,"end":17,"name":"PUSH #[$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":0,"end":17,"name":"DUP1"},{"begin":0,"end":17,"name":"PUSH [$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":0,"end":17,"name":"PUSH","value":"0"},{"begin":0,"end":17,"name":"CODECOPY"},{"begin":0,"end":17,"name":"PUSH","value":"0"},{"begin":0,"end":17,"name":"RETURN"}],".data":{"0":{".code":[{"begin":0,"end":17,"name":"PUSH","value":"60"},{"begin":0,"end":17,"name":"PUSH","value":"40"},{"begin":0,"end":17,"name":"MSTORE"},{"begin":0,"end":17,"name":"PUSH [tag]","value":"1"},{"begin":0,"end":17,"name":"JUMP"},{"begin":0,"end":17,"name":"tag","value":"1"},{"begin":0,"end":17,"name":"JUMPDEST"},{"begin":0,"end":17,"name":"PUSH [ErrorTag]"},{"begin":0,"end":17,"name":"JUMP"}]}}},"bytecode":"6060604052600c8060106000396000f360606040526008565b600256","functionHashes":{},"gasEstimates":{"creation":[39,2400],"external":{},"internal":{}},"interface":"[]\n","opcodes":"PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0xC DUP1 PUSH1 0x10 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x8 JUMP JUMPDEST PUSH1 0x2 JUMP ","runtimeBytecode":"60606040526008565b600256","srcmap":"0:17:0:-;;;;;;;;;","srcmapRuntime":"0:17:0:-;;;;;;;"},"test2":{"assembly":{".code":[{"begin":18,"end":35,"name":"PUSH","value":"60"},{"begin":18,"end":35,"name":"PUSH","value":"40"},{"begin":18,"end":35,"name":"MSTORE"},{"begin":18,"end":35,"name":"PUSH #[$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":18,"end":35,"name":"DUP1"},{"begin":18,"end":35,"name":"PUSH [$]","value":"0000000000000000000000000000000000000000000000000000000000000000"},{"begin":18,"end":35,"name":"PUSH","value":"0"},{"begin":18,"end":35,"name":"CODECOPY"},{"begin":18,"end":35,"name":"PUSH","value":"0"},{"begin":18,"end":35,"name":"RETURN"}],".data":{"0":{".code":[{"begin":18,"end":35,"name":"PUSH","value":"60"},{"begin":18,"end":35,"name":"PUSH","value":"40"},{"begin":18,"end":35,"name":"MSTORE"},{"begin":18,"end":35,"name":"PUSH [tag]","value":"1"},{"begin":18,"end":35,"name":"JUMP"},{"begin":18,"end":35,"name":"tag","value":"1"},{"begin":18,"end":35,"name":"JUMPDEST"},{"begin":18,"end":35,"name":"PUSH [ErrorTag]"},{"begin":18,"end":35,"name":"JUMP"}]}}},"bytecode":"6060604052600c8060106000396000f360606040526008565b600256","functionHashes":{},"gasEstimates":{"creation":[39,2400],"external":{},"internal":{}},"interface":"[]\n","opcodes":"PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0xC DUP1 PUSH1 0x10 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN PUSH1 0x60 PUSH1 0x40 MSTORE PUSH1 0x8 JUMP JUMPDEST PUSH1 0x2 JUMP ","runtimeBytecode":"60606040526008565b600256","srcmap":"18:17:0:-;;;;;;;;;","srcmapRuntime":"18:17:0:-;;;;;;;"}},"errors":["Untitled:1:1: Warning: Source file does not specify required compiler version!Consider adding \"pragma solidity ^0.4.3\ncontract test1 {} contract test2 {}\n^---------------------------------^\n"],"formal":{"errors":["Untitled:1:19: Error: More than one contract not supported.\ncontract test1 {} contract test2 {}\n                  ^---------------^\n"]},"sourceList":["Untitled"],"sources":{"Untitled":{"AST":{"children":[{"attributes":{"fullyImplemented":true,"isLibrary":false,"linearizedBaseContracts":[5579100],"name":"test1"},"children":[],"id":5579100,"name":"ContractDefinition","src":"0:17:0"},{"attributes":{"fullyImplemented":true,"isLibrary":false,"linearizedBaseContracts":[5584588],"name":"test2"},"children":[],"id":5584588,"name":"ContractDefinition","src":"18:17:0"}],"name":"SourceUnit"}}}}},"1Untitledpragmasolidity^0.4.0contractBallot{structVoter{uintweightboolvoteduint8voteaddressdelegate}structProposal{uintvoteCount}addresschairpersonmapping(address=>Voter)votersProposal[]proposals///Createanewballotwith$(_numProposals)differentproposals.functionBallot(uint8_numProposals){chairperson=msg.sendervoters[chairperson].weight=1proposals.length=_numProposals}///Give$(voter)therighttovoteonthisballot.///Mayonlybecalledby$(chairperson).functiongiveRightToVote(addressvoter){if(msg.sender!=chairperson||voters[voter].voted)returnvoters[voter].weight=1}///Delegateyourvotetothevoter$(to).functiondelegate(addressto){Votersender=voters[msg.sender]//assignsreferenceif(sender.voted)returnwhile(voters[to].delegate!=address(0)&&voters[to].delegate!=msg.sender)to=voters[to].delegateif(to==msg.sender)returnsender.voted=truesender.delegate=toVoterdelegate=voters[to]if(delegate.voted)proposals[delegate.vote].voteCount+=sender.weightelsedelegate.weight+=sender.weight}///Giveasinglevotetoproposal$(proposal).functionvote(uint8proposal){Votersender=voters[msg.sender]if(sender.voted||proposal>=proposals.length)returnsender.voted=truesender.vote=proposalproposals[proposal].voteCount+=sender.weight}functionwinningProposal()constantreturns(uint8winningProposal){uint256winningVoteCount=0for(uint8proposal=0;proposal<proposals.length;proposal++)if(proposals[proposal].voteCount>winningVoteCount){winningVoteCount=proposals[proposal].voteCountwinningProposal=proposal}}}":{"key":"1Untitledpragmasolidity^0.4.0contractBallot{structVoter{uintweightboolvoteduint8voteaddressdelegate}structProposal{uintvoteCount}addresschairpersonmapping(address=>Voter)votersProposal[]proposals///Createanewballotwith$(_numProposals)differentproposals.functionBallot(uint8_numProposals){chairperson=msg.sendervoters[chairperson].weight=1proposals.length=_numProposals}///Give$(voter)therighttovoteonthisballot.///Mayonlybecalledby$(chairperson).functiongiveRightToVote(addressvoter){if(msg.sender!=chairperson||voters[voter].voted)returnvoters[voter].weight=1}///Delegateyourvotetothevoter$(to).functiondelegate(addressto){Votersender=voters[msg.sender]//assignsreferenceif(sender.voted)returnwhile(voters[to].delegate!=address(0)&&voters[to].delegate!=msg.sender)to=voters[to].delegateif(to==msg.sender)returnsender.voted=truesender.delegate=toVoterdelegate=voters[to]if(delegate.voted)proposals[delegate.vote].voteCount+=sender.weightelsedelegate.weight+=sender.weight}///Giveasinglevotetoproposal$(proposal).functionvote(uint8proposal){Votersender=voters[msg.sender]if(sender.voted||proposal>=proposals.length)returnsender.voted=truesender.vote=proposalproposals[proposal].voteCount+=sender.weight}functionwinningProposal()constantreturns(uint8winningProposal){uint256winningVoteCount=0for(uint8proposal=0;proposal<proposals.length;proposal++)if(proposals[proposal].voteCount>winningVoteCount){winningVoteCount=proposals[proposal].voteCountwinningProposal=proposal}}}","source":{"sources":{"Untitled":"pragma solidity ^0.4.0\ncontract Ballot {\n\n    struct Voter {\n        uint weight\n        bool voted\n        uint8 vote\n        address delegate\n    }\n    struct Proposal {\n        uint voteCount\n    }\n\n    address chairperson\n    mapping(address => Voter) voters\n    Proposal[] proposals\n\n    /// Create a new ballot with $(_numProposals) different proposals.\n    function Ballot(uint8 _numProposals) {\n        chairperson = msg.sender\n        voters[chairperson].weight = 1\n        proposals.length = _numProposals\n    }\n\n    /// Give $(voter) the right to vote on this ballot.\n    /// May only be called by $(chairperson).\n    function giveRightToVote(address voter) {\n        if (msg.sender != chairperson || voters[voter].voted) return\n        voters[voter].weight = 1\n    }\n\n    /// Delegate your vote to the voter $(to).\n    function delegate(address to) {\n        Voter sender = voters[msg.sender] // assigns reference\n        if (sender.voted) return\n        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)\n            to = voters[to].delegate\n        if (to == msg.sender) return\n        sender.voted = true\n        sender.delegate = to\n        Voter delegate = voters[to]\n        if (delegate.voted)\n            proposals[delegate.vote].voteCount += sender.weight\n        else\n            delegate.weight += sender.weight\n    }\n\n    /// Give a single vote to proposal $(proposal).\n    function vote(uint8 proposal) {\n        Voter sender = voters[msg.sender]\n        if (sender.voted || proposal >= proposals.length) return\n        sender.voted = true\n        sender.vote = proposal\n        proposals[proposal].voteCount += sender.weight\n    }\n\n    function winningProposal() constant returns (uint8 winningProposal) {\n        uint256 winningVoteCount = 0\n        for (uint8 proposal = 0; proposal < proposals.length; proposal++)\n            if (proposals[proposal].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[proposal].voteCount\n                winningProposal = proposal\n            }\n    }\n}\n"}},"optimization":1,"missingInputs":[],"result":{"errors":["Untitled:59:34: Error: Expected import directive or contract definition.\n        for (uint8 proposal = 0; proposal < proposals.length; proposal++)\n                                 ^\n"]}},"0Untitledpragmasolidity^0.4.0contractBallot{structVoter{uintweightboolvoteduint8voteaddressdelegate}structProposal{uintvoteCount}addresschairpersonmapping(address=>Voter)votersProposal[]proposals///Createanewballotwith$(_numProposals)differentproposals.functionBallot(uint8_numProposals){chairperson=msg.sendervoters[chairperson].weight=1proposals.length=_numProposals}///Give$(voter)therighttovoteonthisballot.///Mayonlybecalledby$(chairperson).functiongiveRightToVote(addressvoter){if(msg.sender!=chairperson||voters[voter].voted)returnvoters[voter].weight=1}///Delegateyourvotetothevoter$(to).functiondelegate(addressto){Votersender=voters[msg.sender]//assignsreferenceif(sender.voted)returnwhile(voters[to].delegate!=address(0)&&voters[to].delegate!=msg.sender)to=voters[to].delegateif(to==msg.sender)returnsender.voted=truesender.delegate=toVoterdelegate=voters[to]if(delegate.voted)proposals[delegate.vote].voteCount+=sender.weightelsedelegate.weight+=sender.weight}///Giveasinglevotetoproposal$(proposal).functionvote(uint8proposal){Votersender=voters[msg.sender]if(sender.voted||proposal>=proposals.length)returnsender.voted=truesender.vote=proposalproposals[proposal].voteCount+=sender.weight}functionwinningProposal()constantreturns(uint8winningProposal){uint256winningVoteCount=0for(uint8proposal=0;proposal<proposals.length;proposal++)if(proposals[proposal].voteCount>winningVoteCount){winningVoteCount=proposals[proposal].voteCountwinningProposal=proposal}}}":{"key":"0Untitledpragmasolidity^0.4.0contractBallot{structVoter{uintweightboolvoteduint8voteaddressdelegate}structProposal{uintvoteCount}addresschairpersonmapping(address=>Voter)votersProposal[]proposals///Createanewballotwith$(_numProposals)differentproposals.functionBallot(uint8_numProposals){chairperson=msg.sendervoters[chairperson].weight=1proposals.length=_numProposals}///Give$(voter)therighttovoteonthisballot.///Mayonlybecalledby$(chairperson).functiongiveRightToVote(addressvoter){if(msg.sender!=chairperson||voters[voter].voted)returnvoters[voter].weight=1}///Delegateyourvotetothevoter$(to).functiondelegate(addressto){Votersender=voters[msg.sender]//assignsreferenceif(sender.voted)returnwhile(voters[to].delegate!=address(0)&&voters[to].delegate!=msg.sender)to=voters[to].delegateif(to==msg.sender)returnsender.voted=truesender.delegate=toVoterdelegate=voters[to]if(delegate.voted)proposals[delegate.vote].voteCount+=sender.weightelsedelegate.weight+=sender.weight}///Giveasinglevotetoproposal$(proposal).functionvote(uint8proposal){Votersender=voters[msg.sender]if(sender.voted||proposal>=proposals.length)returnsender.voted=truesender.vote=proposalproposals[proposal].voteCount+=sender.weight}functionwinningProposal()constantreturns(uint8winningProposal){uint256winningVoteCount=0for(uint8proposal=0;proposal<proposals.length;proposal++)if(proposals[proposal].voteCount>winningVoteCount){winningVoteCount=proposals[proposal].voteCountwinningProposal=proposal}}}","source":{"sources":{"Untitled":"pragma solidity ^0.4.0\ncontract Ballot {\n\n    struct Voter {\n        uint weight\n        bool voted\n        uint8 vote\n        address delegate\n    }\n    struct Proposal {\n        uint voteCount\n    }\n\n    address chairperson\n    mapping(address => Voter) voters\n    Proposal[] proposals\n\n    /// Create a new ballot with $(_numProposals) different proposals.\n    function Ballot(uint8 _numProposals) {\n        chairperson = msg.sender\n        voters[chairperson].weight = 1\n        proposals.length = _numProposals\n    }\n\n    /// Give $(voter) the right to vote on this ballot.\n    /// May only be called by $(chairperson).\n    function giveRightToVote(address voter) {\n        if (msg.sender != chairperson || voters[voter].voted) return\n        voters[voter].weight = 1\n    }\n\n    /// Delegate your vote to the voter $(to).\n    function delegate(address to) {\n        Voter sender = voters[msg.sender] // assigns reference\n        if (sender.voted) return\n        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)\n            to = voters[to].delegate\n        if (to == msg.sender) return\n        sender.voted = true\n        sender.delegate = to\n        Voter delegate = voters[to]\n        if (delegate.voted)\n            proposals[delegate.vote].voteCount += sender.weight\n        else\n            delegate.weight += sender.weight\n    }\n\n    /// Give a single vote to proposal $(proposal).\n    function vote(uint8 proposal) {\n        Voter sender = voters[msg.sender]\n        if (sender.voted || proposal >= proposals.length) return\n        sender.voted = true\n        sender.vote = proposal\n        proposals[proposal].voteCount += sender.weight\n    }\n\n    function winningProposal() constant returns (uint8 winningProposal) {\n        uint256 winningVoteCount = 0\n        for (uint8 proposal = 0; proposal < proposals.length; proposal++)\n            if (proposals[proposal].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[proposal].voteCount\n                winningProposal = proposal\n            }\n    }\n}\n"}},"optimization":0,"missingInputs":[],"result":{"errors":["Untitled:59:34: Error: Expected import directive or contract definition.\n        for (uint8 proposal = 0; proposal < proposals.length; proposal++)\n                                 ^\n"]}}};
